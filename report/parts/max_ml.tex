
\subsection{Первый прототип классификатора (Максим Макаров)}
Также, несмотря на то что это не входило в список моих задач, я решил попробовать создать первый прототип классификатора обработанных данных.
% Моими основными задачами были доработка мобильного приложения и создание классификатора обработанных данных.
Так как обработанные данные есть ни что иное, как фигура на плоскости, было рассмотрено несколько вариантов классификации этих самых данных:
\begin{enumerate}
    \item Классифицировать фигуры без какой-либо дополнительной обработки
    \item Нормировать фигуры по максимальному отклонению от точки (0; 0)
    \item Построить графики с помощью программной библиотеки mathplotlib, после чего классифицировать полученные изображения
\end{enumerate}
В связи с тем, что классификация изображений является весьма распространенной задачей, то было решено выбрать следующую стратегию: строить графики показаний акселерометра с помощью программной библиотеки mathplotlib и классифицировать полученные изображения.

Таким образом, возникли следующие подзадачи:
\begin{enumerate}
    \item Построить графики с помощью программной библиотеки mathplotlib
    \item Классифицировать полученные изображения, используя методы машинного обучения
    \item Добавить вывод предсказаний в мобильное приложение
\end{enumerate}
Благодаря лабораторным работам по линейной алгебре имелся достаточно богатый опыт использования программной библиотеки mathplotlib, поэтому построение графиков не составило труда. Однако, необходимо было избавиться от посторонних данных на графиках, таких как шкалы и вспомогательные сетки, а также привести все данные к единому формату: квадратные изображения строго определенного размера, одинаковый масштаб по оси абсцисс и по оси ординат.

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{cc}
            \includegraphics[width=0.4\textwidth]{max_kt2_images/image4.jpg} & 
            \includegraphics[width=0.4\textwidth]{max_kt2_images/image2.jpg} \\
        \end{tabular}
    \end{center}
    \caption{Примеры полученных изображений различных жестов: круг (слева), встряхивание (справа).}
\end{figure}

% Дополнительно, бонусом такого решения является то, что изображения нормируются по размеру автоматически.

Далее, я приступил к поиску подходящей программной библиотеки машинного обучения. Были рассмотрены следующие варианты:
\begin{enumerate}
    \item Theano -- библиотека численного вычисления в Python. Вычисления в Theano выражаются NumPy-подобным синтаксисом и компилируются для эффективных параллельных вычислений как на обычных CPU, так и на GPU.
    \item TensorFlow — открытая программная библиотека для машинного обучения, разработанная компанией Google для решения задач построения и тренировки нейронной сети с целью автоматического нахождения и классификации образов, достигая качества человеческого восприятия.
    \item Apache MXNet —  это программная платформа глубокого обучения с открытым исходным кодом, используемая для обучения и развертывания глубоких нейронных сетей.
\end{enumerate}

В связи с популярностью программной библиотеки TensorFlow и, как следствие, обилием готовых решений, основанных на ней, выбор был очевиден. Также данная библиотека является достаточно производительной, так как вся работа ведется с графами вычислений, операции с которыми, можно эффективно исполнять на некоторых типах процессоров.  Так как опыта работы с TensorFlow у меня не было совсем, первым делом было решено искать примеры проектов, сделанных на основе этой программной библиотеки. В процессе поиска я наткнулся на очень интересное решение от Google – Teachable Machine. Это инструмент, основанный на веб-технологиях, который делает обучение моделей быстрым, легким и доступным каждому, а также позволяет экспортировать полученные модели для интеграции в собственные решения.

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{max_kt2_images/image10.png}
    \end{center}
    \caption{Интерфейс программы “Teachable Machine”.}
\end{figure}

В программе предустановлены 3 модели: для распознавания изображений, аудиозаписей и поз. Нас интересует первая модель – это сверточная нейронная сеть. Данный тип искусственных нейронных нейронных сетей хорошо зарекомендовал себя в задачах распознавания образов. Главное отличие сверточных нейронных сетей от обыкноневенного перцептрона, то есть полносвязной нейронной сети, в том, что она обучается на основе карт признаков, которые формируются в результате операций свертки матрицами весов различных фильтров. Сами же матрицы весов корректируются в процессе обучения методом обратного распространения ошибки.

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{max_kt2_images/image7.png}
    \end{center}
    \caption{Типовая архитектура сверточной нейронной сети.}
\end{figure}

% Принцип работы Teachable Machine прост: в левом меню создаются классы и для каждого загружается набор тренировочных изображений или аудиозаписей в зависимости от выбранного ранее типа модели. При необходимости можно указать дополнительные параметры обучения (скорость обучения, количество эпох и т.д.), однако, как выяснилось позже, стандартные параметры обучения позволяют добиться достаточно неплохих результатов. Затем, полученную модель можно экспортировать в формате “.h5”.

Далее, нужно было определиться с классами движений. После совещания с другими участниками команды, мы остановились на том, что система будет уметь распознавать три типа жестов: круг, квадрат и встряхивание. Недолго думая, один из участников команды приступил к сбору датасета и уже через пару часов, в моих руках было 15 экземпляров “кругов”, 14 “квадратов” и столько же “встряхиваний”. Далее, данный набор данных был загружен в Teachable Machine, а также была запущена тренировка со стандартными настройками (50 эпох, batch size = 16, скорость обучения = 0,001).  После чего, модель была экспортирована для использования вместе с интерпретируемым языком программирования Python 3. Сразу же захотелось протестировать данную модель: из другого набора данных были выбраны несколько записанных ранее жестов в виде графиков, которые после стали входными данными для алгоритма распознавания. Были получены следующие результаты:

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{cc}
            \includegraphics[width=0.35\textwidth]{max_kt2_images/image4.jpg} & 
            \includegraphics[width=0.35\textwidth]{max_kt2_images/image11.png} \\
        \end{tabular}
    \end{center}
    \caption{Исходное изображение круга (слева) и результат работы алгоритма (справа).}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{cc}
            \includegraphics[width=0.35\textwidth]{max_kt2_images/image9.jpg} & 
            \includegraphics[width=0.35\textwidth]{max_kt2_images/image8.png} \\
        \end{tabular}
    \end{center}
    \caption{Исходное изображение встряхивания (слева) и результат работы алгоритма (справа).}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{cc}
            \includegraphics[width=0.35\textwidth]{max_kt2_images/image3.jpg} & 
            \includegraphics[width=0.35\textwidth]{max_kt2_images/image1.png} \\
        \end{tabular}
    \end{center}
    \caption{Исходное изображение квадрата (слева) и результат работы алгоритма (справа).}
\end{figure}
